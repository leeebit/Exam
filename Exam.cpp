//CREATED BY 2GAPUH AND CHATGPT - 3.5
//ОГЛАВЛЕНИЕ
//Вопрос 1. История развития языков программирования.	3
//Вопрос 2. Основные свойства объектно - ориентированных языков программирования	4
//Вопрос 3. История развития С++	5
//Вопрос 4. С++ как улучшение Си.Комментарии.Константы.Встраиваемые функции.Объявление структур, объединений, перечислений.Объявление переменных.	6
//Вопрос 5. Ссылки	7
//Вопрос 6 Использование спецификатора void	8
//Вопрос 7. Преобразование стандартных типов данных	8
//Вопрос 8. Новые операции new, delete, операция расширения области видимости	9
//Вопрос 9. Объявление функций.Аргументы по умолчанию.	11
//Вопрос 10. Перегрузка функций	11
//Вопрос 11. Использование функций Си в программе на С++	12
//Вопрос 12. С++ как Си с классами.Определение класса.Конструкторы и деструкторы.	13
//Вопрос 13. Перегрузка операций	15
//Вопрос 14. Дружественные функции	16
//Вопрос 15. Сходства и различия классов, структур, объединений.Совместимость Си и С++.	17
//Вопрос 16. Классы и объекты.Определение класса и области видимости.Опережающее определение класса.	18
//Вопрос 17. Использование спецификатора класса памяти static.Статические компоненты класса.	20
//Вопрос 18. Константные объекты и константные методы.	21
//Вопрос 19. Неявный указатель this	22
//Вопрос 20. Указатели на член класса.	23
//Вопрос 21. Локальные и вложенные классы.	24
//Вопрос 22. Специальный вид методов класса – конструкторы и деструкторы.Некоторые особенности конструкторов и деструкторов.	25
//Вопрос 23. Программирование методов.Программирование методов и принцип модульности.Представление алгоритмической компоненты класса в виде множества мелких методов, вызывающих друг друга.Создание вспомогательных локальных объектов при выполнении операций над основными объектами класса.	27
//Вопрос 24. Программирование методов.Способы передачи параметров в методы.Конвейер ссылок и конвейер значений.	29
//Вопрос 25. Классы, содержащие объекты других классов	30
//Вопрос 26. Создание объектов с различным временем жизни	31
//Вопрос 27. Массивы объектов класса	32
//Вопрос 28. Особенности копирования объектов	33
//Вопрос 29. Заготовка класса без наследника	35
//Вопрос 30. Пример вектора с не поверхностным копированием	35
//Вопрос 31. Излишнее копирование.Конструктор копии.Операция присваивания.	37
//Вопрос 32. Преобразование типов.Стандартное преобразование.Явное преобразование.	38
//Вопрос 33. Преобразование абстрактных типов данных(преобразование типов данных, созданных программистом)	39
//Вопрос 34. Наследование классов	41
//Вопрос 35. Доступ к наследуемым членам класса	42
//Вопрос 36. Стандартные преобразования типов при наследовании	44
//Вопрос 37. Инициализация объекта порожденного класса.Конструктор копии.Операция присваивания.	45
//Вопрос 38. Множественное наследование.Двусмысленности при множественном наследовании.Виртуальные базовые классы.Инициализация виртуального базового класса.Порядок вызовов конструкторов и деструкторов в случае нескольких базовых классов.	47
//Вопрос 39. Виртуальные функции.Объявление виртуальных функций.Чисто виртуальные функции.	48
//Вопрос 40. Таблица виртуальных функций.Случаи, когда вызов виртуальной функции не будет виртуальным.Виртуальные деструкторы.	50
//Вопрос 41. Ввод - вывод файлов.Потоки ввода - вывода.Библиотека ввода - вывода(iostream).Группы классов библиотеки ввода - вывода.	52
//Вопрос 42. Шаблоны функций С++	53
//Вопрос 43. Шаблоны классов С++.Определение шаблона класса.Явная реализация некоторых методов для специфических типов.Полное переопределение шаблона класса для работы с некоторым особым типом.Шаблоны и дружественные функции.Шаблоны и наследование.Шаблоны и конфигурация компилятора.Достоинства и недостатки шаблонов.	54
//
//Вопрос 1. История развития языков программирования.
//1.	Машинный код : Первые компьютеры программировались на машинных кодах, представляющих инструкции, понятные только процессору.
//2.	Ассемблер : появился для более удобной работы с машинными кодами.Использовал мнемоники для инструкций процессора, делая их более читаемыми.
//3.	Фортран(FORTRAN) : Один из самых ранних высокоуровневых языков, созданный для научных вычислений в 1950 - х.Его основное преимущество - понятные математические обозначения.
//4.	COBOL : появился в 1960 - х для бизнес - приложений.Его синтаксис ориентирован на человека, что облегчает чтение программ.
//5.	LISP : Первый функциональный язык, разработанный для искусственного интеллекта.Он использовал списки и рекурсию.
//6.	C : Создан в 1970 - х.Это универсальный язык, известный своей эффективностью и широким применением в системном программировании.
//7.	Java : В 1995 году Java вышла как универсальный, надежный язык с возможностью запуска на любой платформе.
//8.	Python : Создан в конце 1980 - х, но стал популярным в последние десятилетия благодаря своей простоте и читаемости кода.
//9.	JavaScript : Разработан в 1995 году для добавления интерактивности на веб - страницах, сейчас является одним из основных языков веб - разработки.
//Вопрос 2. Основные свойства объектно - ориентированных языков программирования
//Объектно - ориентированное программирование(ООП) - это парадигма программирования, основанная на концепции объектов, которые содержат данные в виде полей(или свойств) и код в виде методов.Вот основные свойства объектно - ориентированных языков :
//1.	Инкапсуляция : это свойство позволяет объединить данные и методы, обрабатывающие эти данные, в единый объект.Это помогает скрыть детали реализации и предоставить интерфейс для взаимодействия с объектом.
//2.	Наследование : Одни объекты могут наследовать свойства и методы других объектов.Это позволяет создавать иерархии классов, где дочерние классы могут использовать функциональность родительских классов, а также добавлять свои уникальные свойства и методы.
//3.	Полиморфизм : это возможность объектов одного класса использовать методы другого класса.Полиморфизм позволяет использовать один и тот же метод для различных типов данных.
//4.	Абстракция : это процесс создания абстрактных классов или интерфейсов, которые определяют общие характеристики объектов.Абстракция позволяет скрыть детали реализации и предоставить только необходимый функционал.
//5.	Классы и объекты : Классы — это шаблоны, описывающие состояние(поля) и поведение(методы) объектов.Объекты — это экземпляры классов, которые содержат конкретные данные и могут вызывать методы класса.
//Вопрос 3. История развития С++
//C++ — это расширение языка программирования C, которое добавляет возможности объектно - ориентированного программирования(ООП) и другие усовершенствования.Его история берет начало в 1979 году, когда Дж.Страуструп начал работу над расширением языка C, которое стало известным как C++.
//1.	Возникновение : В начале 1980 - х Дж.Страуструп начал разрабатывать C++, называемый "C с классами".Он добавил объектно - ориентированные возможности к языку C, включая классы, наследование, полиморфизм.
//2.	Стандартизация : В 1983 году была выпущена первая версия C++, а в 1985 году был опубликован "The C++ Programming Language" (книга Страуструпа).В 1998 году был принят первый стандарт языка C++ (C++98), который включал множество улучшений и новых возможностей.
//3.	Стандарт C++11 : Одним из значимых моментов в истории C++ является выпуск стандарта C++11 в 2011 году.Он добавил много новых функций, таких как автоматическая типизация(auto), лямбда - выражения, умные указатели, расширения для стандартной библиотеки и другие.
//4.	Последующие стандарты : затем выходили последующие версии стандарта : C++14, C++17, C++20 и так далее.Они добавляли новые возможности, улучшали язык, повышали производительность и упрощали разработку.
//Вопрос 4. С++ как улучшение Си.Комментарии.Константы.Встраиваемые функции.Объявление структур, объединений, перечислений.Объявление переменных.
//0сновные аспекты C++, которые представляют собой улучшения относительно C.
//1.	Комментарии : C++ расширяет способы комментирования кода.Он поддерживает как комментарии в стиле C(/* ... */), так и встроенные в C++ однострочные комментарии(//). Последние удобны для быстрого комментирования кода.
//    2.	Константы: В C++ можно использовать ключевое слово const для объявления констант.Константы в C++ более предпочтительны для использования, чем макросы #define, потому что они обеспечивают типовую проверку и область видимости.
//    3.	Встраиваемые функции : C++ предоставляет ключевое слово inline, позволяющее указывать компилятору на возможность инлайн - раскрытия функций.Это помогает ускорить выполнение программы за счет уменьшения накладных расходов на вызов функций.
//    4.	Объявление структур, объединений, перечислений : В C++ объявление структур, объединений и перечислений остается схожим с C, но C++ добавляет дополнительные возможности, такие как наследование и функции - члены в структурах.
//    5.	Объявление переменных : C++ позволяет объявлять переменные в любом месте блока кода, в отличие от C, где все переменные должны быть объявлены в начале блока.Также в C++ появились ссылки(&), что обеспечивает более безопасное и гибкое управление памятью.
//    Вопрос 5. Ссылки
//    В C++ ссылки представляют собой механизм, позволяющий создавать псевдонимы для существующих объектов или значений.Они предоставляют удобный способ работы с данными без копирования значений, что может быть полезно при передаче аргументов функциям или при работе с большими объемами данных.
//    Вот основные характеристики ссылок в C++ :
//    1.	Создание ссылок : Ссылки создаются с использованием оператора & в момент объявления.Например : int a = 10; int& refA = a; создает ссылку refA на переменную a.
//    2.	Ссылки и указатели : Ссылки отличаются от указателей тем, что они всегда должны быть инициализированы и не могут быть переназначены для ссылки на другой объект после инициализации.Они всегда указывают на тот же объект.
//    3.	Передача аргументов по ссылке : при передаче аргументов в функции по ссылке, функция получает доступ к исходным данным, а не их копии.Это позволяет изменять переданные значения внутри функции.
//    4.	Ссылки и объекты : Ссылки часто используются для управления объектами в ООП.Например, в методах классов можно использовать ссылки для доступа к членам класса без копирования данных.
//    5.	Константные ссылки : можно создавать ссылки на константные данные с помощью const.Например, const int& refConst = someValue; создает ссылку, которая не позволяет изменять someValue.
//    Вопрос 6 Использование спецификатора void
//    Спецификатор void в языке программирования C++ имеет несколько различных контекстов использования :
//1.	Функции, возвращающие void : Функции, которые не возвращают никакого значения, объявляются с возвращаемым типом void.Например :
//    void doSomething() { // код функции } 
//    Это означает, что функция doSomething не возвращает никакого значения при ее вызове.
//        2.	Указатели на void: Указатель void* является универсальным указателем, который может хранить адрес любого типа данных.Он используется в случаях, когда тип данных, хранящихся по адресу, неизвестен или не важен на этапе компиляции.Пример :
//        void* ptr;
//    int num = 10;
//    ptr = &num; // ptr теперь указывает на переменную типа int 
//    3.	Функции без аргументов : если функция не принимает аргументы, то ее список параметров может быть обозначен как void, чтобы явно указать отсутствие аргументов :
//    void functionWithNoArgs(void) { // код функции без аргументов } 
//        В современном стандарте C++, в большинстве случаев указание void в списке параметров функции можно опустить.
//            Вопрос 7. Преобразование стандартных типов данных
//            Преобразование типов данных — это процесс изменения типа переменной или выражения из одного типа в другой.В C++ есть несколько способов преобразования стандартных типов данных :
//        1.	Неявное преобразование(автоматическое) : происходит автоматически при выполнении операций между разными типами данных.Например, если вы пытаетесь сложить int и double, int будет неявно преобразован в double для выполнения операции.
//            int a = 5;
//        double b = 2.5;
//        double result = a + b; // int a будет неявно преобразован в double для выполнения операции 
//        2.	Явное преобразование(приведение типов) : это преобразование, которое производится программистом с помощью операторов явного приведения типа.
//            •	Статическое приведение типов(C - style cast) :
//            double d = 2.75;
//        int i = (int)d; // явное преобразование double в int 
//        •	static_cast: это оператор для выполнения безопасных преобразований между типами.Например :
//            double x = 10.5;
//        int y = static_cast<int>(x); // преобразование double в int с использованием static_cast 
//        •	dynamic_cast, reinterpret_cast, const_cast: Эти операторы предназначены для особых случаев преобразования, таких как приведение типов во время выполнения программы(dynamic_cast), приведение указателей или ссылок(reinterpret_cast), а также удаление const или volatile квалификаторов(const_cast).
//            Вопрос 8. Новые операции new, delete, операция расширения области видимости
//            Операторы new и delete в C++ используются для динамического выделения и освобождения памяти соответственно.
//            1.	new и delete :
//            •	new : выделяет память для одного объекта и возвращает указатель на выделенную память.Может использоваться для создания объектов как базовых типов, так и пользовательских классов.
//            int* ptr = new int; // выделение памяти для int 
//        •	delete: освобождает память, выделенную оператором new.Если вы не освободите память, выделенную с помощью new, может возникнуть утечка памяти.
//            delete ptr; // освобождение памяти 
//        2.	Операция расширения области видимости(::) : В C++ операция::используется для обращения к членам класса или к глобальным переменным изнутри области видимости, например, из метода класса.
//            •	Для доступа к глобальным переменным изнутри класса :
//        int globalVar = 5;
//        class MyClass
//        {
//        public:
//            void printGlobalVar()
//            {
//                cout << "Global variable accessed from MyClass: " << ::globalVar << endl;
//            }
//        };
//        •	Для доступа к статическим переменным или методам класса из внешнего кода :
//        class MyClass {
//        public:
//            static int staticVar;
//            static void staticMethod() {
//                cout << "Accessed static method from MyClass" << endl;
//            }
//        };
//
//        int MyClass::staticVar = 10; // определение статической переменной
//
//        int main() {
//            MyClass::staticMethod(); // вызов статического метода
//            cout << "Accessed static variable from main: " << MyClass::staticVar << endl;
//            return 0;
//        }
//        Оператор::позволяет управлять областью видимости и явно указывать, к каким членам класса или глобальным переменным нужно обращаться из различных областей кода.
//            Вопрос 9. Объявление функций.Аргументы по умолчанию.
//            Объявление функций в C++ позволяет определить прототип функции перед её фактической реализацией.Это позволяет компилятору знать о существовании функции и какие аргументы она принимает, прежде чем она будет вызвана.
//            Пример объявления функции :
//        // Объявление функции без аргументов и возвращаемого значения
//        void doSomething();
//
//        // Объявление функции с аргументами и возвращаемым значением
//        int add(int a, int b);
//        Аргументы по умолчанию : В C++ можно установить значения по умолчанию для аргументов функции.Это означает, что, если значение для аргумента не передано при вызове функции, будет использовано значение по умолчанию, указанное при объявлении функции.
//            Примеры использования аргументов по умолчанию :
//        // Функция с аргументами по умолчанию
//        void printMessage(string message = "Hello") {
//            cout << message << endl;
//        }
//
//        // Вызов функции без передачи аргумента (используется значение по умолчанию)
//        printMessage(); // Выведет "Hello"
//
//        // Вызов функции с передачей аргумента
//        printMessage("Bonjour"); // Выведет "Bonjour"
//        Аргументы по умолчанию полезны для создания более гибких функций, которые могут быть вызваны с различным количеством аргументов.Они позволяют упростить интерфейсы функций, делая их более удобными для использования.
//            Вопрос 10. Перегрузка функций
//            Перегрузка функций в C++ позволяет определять несколько функций с одинаковыми именами, но с различными списками аргументов или типами данных.Это позволяет создавать функции с одним именем, но разным поведением в зависимости от переданных аргументов.
//            Пример перегрузки функций :
//        // Перегрузка функции add для разных типов данных
//        int add(int a, int b) {
//            return a + b;
//        }
//
//        double add(double a, double b) {
//            return a + b;
//        }
//
//        // Перегрузка функции для разного количества аргументов
//        int add(int a, int b, int c) {
//            return a + b + c;
//        }
//        В примере выше функция add перегружена тремя различными вариантами : для int, для double и для трех int.Компилятор определяет, какая функция будет вызвана, основываясь на типах и количестве переданных аргументов.
//            Основные правила перегрузки функций :
//        •	Функции должны иметь разные списки аргументов(типы аргументов или их количество).
//            •	Возвращаемый тип функции не учитывается при определении перегруженности функций.
//            •	Можно перегружать как методы класса, так и глобальные функции.
//            Вопрос 11. Использование функций Си в программе на С++
//            C++ поддерживает использование функций из языка C без каких - либо проблем.Это позволяет вам использовать функции из библиотек на C в ваших программных проектах на C++.Вот несколько вариантов использования функций Си в программах на C++ :
//            1.	Использование заголовочных файлов : Вы можете включить заголовочные файлы Си(.h) в свои файлы C++ и использовать функции из этих заголовочных файлов напрямую в вашем коде C++.
//#include <stdio.h>
//
//            int main() {
//            printf("Hello from C!\n");
//            return 0;
//        }
//        2.	Использование extern "C": если вы используете компилятор C++ для работы с кодом на C, можно использовать extern "C" для явного указания компилятору, что код следует компилировать как код на языке C.
//            extern "C" {
//#include "my_c_library.h"
//        }
//
//        int main() {
//            // Вызов функции из заголовочного файла C
//            someFunctionFromCLibrary();
//            return 0;
//        }
//        Обратите внимание, что внутри блока extern "C" код будет обрабатываться как код на C, что позволяет использовать функции Си в коде C++ без проблем.
//            Вопрос 12. С++ как Си с классами.Определение класса.Конструкторы и деструкторы.
//            C++ был разработан как расширение языка C с добавлением объектно - ориентированных концепций, включая классы.Классы в C++ предоставляют средства для организации данных и функций в единый объект.
//            Определение класса : Класс в C++ — это шаблон, определяющий данные и методы, которые могут быть использованы для работы с этими данными.Он описывает состояние объекта(члены данных) и операции, которые могут быть выполнены над этим объектом(методы).Вот пример определения класса :
//        // Определение класса
//        class MyClass {
//        public: // Область общего доступа
//            // Члены данных
//            int myInt;
//
//            // Метод класса
//            void printMyInt() {
//                cout << "MyInt: " << myInt << endl;
//            }
//        };
//        Конструкторы и деструкторы :
//        •	Конструкторы — это методы класса, вызываемые при создании объекта класса.Они инициализируют объект и могут выполнять различные операции при создании.
//            •	Деструкторы — это методы класса, вызываемые при уничтожении объекта.Они используются для освобождения ресурсов, выделенных объекту.
//            Примеры конструкторов и деструкторов :
//        class MyClass {
//        public:
//            int myInt;
//
//            // Конструктор без параметров
//            MyClass() {
//                myInt = 0; // Инициализация члена данных
//                cout << "Constructor called" << endl;
//            }
//
//            // Пользовательский конструктор с параметром
//            MyClass(int x) {
//                myInt = x; // Инициализация члена данных
//                cout << "Parameterized constructor called" << endl;
//            }
//
//            // Деструктор
//            ~MyClass() {
//                cout << "Destructor called" << endl;
//            }
//
//            void printMyInt() {
//                cout << "MyInt: " << myInt << endl;
//            }
//        };
//
//        int main() {
//            MyClass obj1; // Вызов конструктора без параметров
//            obj1.printMyInt();
//
//            MyClass obj2(42); // Вызов пользовательского конструктора с параметром
//            obj2.printMyInt();
//
//            return 0;
//        } // Вызов деструкторов при выходе из области видимости объектов
//        Конструкторы и деструкторы позволяют инициализировать объекты класса и управлять ресурсами внутри объекта.
//            Вопрос 13. Перегрузка операций
//            Перегрузка операторов в C++ позволяет использовать стандартные операторы для пользовательских типов данных или классов.Это позволяет определить специфическое поведение операторов для ваших объектов.
//            Пример перегрузки операторов :
//        class Complex {
//        private:
//            double real;
//            double imaginary;
//
//        public:
//            Complex(double r, double i) : real(r), imaginary(i) {}
//
//            // Перегрузка оператора сложения (+)
//            Complex operator+(const Complex& other) const {
//                return Complex(real + other.real, imaginary + other.imaginary);
//            }
//
//            // Перегрузка оператора вывода (<<)
//            friend ostream& operator<<(ostream& out, const Complex& c) {
//                out << c.real << " + " << c.imaginary << "i";
//                return out;
//            }
//        };
//
//        int main() {
//            Complex a(2.0, 3.0);
//            Complex b(4.0, 1.5);
//
//            // Использование перегруженного оператора сложения (+)
//            Complex result = a + b;
//
//            // Использование перегруженного оператора вывода (<<)
//            cout << "Result: " << result << endl;
//
//            return 0;
//        }
//        В примере выше перегружен оператор + , который позволяет складывать два объекта класса Complex с помощью оператора + .Также перегружен оператор вывода << , который позволяет выводить объекты Complex с помощью cout.
//            Вопрос 14. Дружественные функции
//            Дружественные функции в C++ — это функции, которые имеют доступ к закрытым и защищенным членам класса, не являясь его членами.Это означает, что функция может обращаться к приватным или защищенным данным класса, даже если она не является методом этого класса.
//            Пример дружественной функции :
//        class MyClass {
//        private:
//            int privateVar;
//
//        public:
//            MyClass() : privateVar(0) {}
//
//            // Объявление дружественной функции
//            friend void friendFunction(MyClass& obj);
//
//            // Методы для доступа к закрытым данным
//            void setPrivateVar(int value) {
//                privateVar = value;
//            }
//
//            int getPrivateVar() {
//                return privateVar;
//            }
//        };
//
//        // Определение дружественной функции
//        void friendFunction(MyClass & obj) {
//            obj.privateVar = 42; // Доступ к закрытому члену класса
//            cout << "Inside friend function: " << obj.privateVar << endl;
//        }
//
//        int main() {
//            MyClass obj;
//            friendFunction(obj); // Вызов дружественной функции
//
//            cout << "Outside friend function: " << obj.getPrivateVar() << endl;
//            return 0;
//        }
//        В этом примере friendFunction объявлена как дружественная функция класса MyClass.Она может обращаться к закрытому члену privateVar класса MyClass.Важно отметить, что дружественные функции обычно используются с осторожностью, так как они могут нарушать инкапсуляцию, однако они могут быть полезны для определенных сценариев, таких как обеспечение доступа к закрытым данным нескольких классов.
//            Вопрос 15. Сходства и различия классов, структур, объединений.Совместимость Си и С++.
//            Вот основные сходства и различия между классами, структурами и объединениями в C++:
//    Структуры:
//        •	Сходство : В C++ структуры являются аналогами классов, за исключением того, что в структурах члены по умолчанию открыты(public), в то время как в классах они по умолчанию закрыты(private).
//            •	Различие : Структуры в C++ могут также иметь методы(функции - члены), конструкторы, деструкторы и другие особенности, что делает их более похожими на классы.
//            Классы :
//            •	Сходство : Классы — это типы данных, которые позволяют объединять данные и функции для их обработки.Они могут иметь конструкторы, деструкторы, методы, а также модификаторы доступа(public, private, protected).
//            •	Различие : Классы по умолчанию имеют модификатор доступа private, а структуры - public.
//            Объединения :
//            •	Сходство : Объединения в C++ похожи на структуры, но все их члены используют одну и ту же память.Таким образом, объединение использует память, которая равна размеру наибольшего члена в объединении.
//            •	Различие : В структурах каждый член использует отдельную область памяти, в отличие от объединений, где все члены используют одну и ту же область памяти.
//            Совместимость Си и С++ :
//            •	Оба языка, Си и C++, обладают схожей базовой структурой : обе поддерживают функции, переменные, указатели, массивы и т.д.
//            •	В большинстве случаев, код на C может быть компилирован в C++, и в C++ можно использовать функции и библиотеки на C.
//            •	Однако, C++ добавляет новые возможности и концепции, такие как классы, перегрузка операторов, исключения, шаблоны и другие, что делает его более мощным и сложным, чем язык C.
//            Совместимость между Си и С++ позволяет использовать код и библиотеки из одного языка в другом, но при этом некоторые особенности Си могут иметь некоторые ограничения в C++.
//            Вопрос 16. Классы и объекты.Определение класса и области видимости.Опережающее определение класса.
//            Классы и объекты являются основными концепциями объектно - ориентированного программирования(ООП) в C++.
//            Классы и объекты :
//        •	Класс : Класс в C++ — это шаблон или чертёж, описывающий структуру и поведение объекта.Он содержит переменные(члены данных) и функции(члены функций), которые определяют поведение объектов этого класса.
//            •	Объект : Объект — это экземпляр класса, созданный на основе определения класса.Он имеет свои собственные наборы данных(члены класса) и может использовать методы класса для выполнения определенных операций.
//            Определение класса и области видимости :
//        •	Классы объявляются с помощью ключевого слова class вместе с именем класса.
//            •	Внутри класса могут находиться переменные и функции, которые имеют различные модификаторы доступа : public, private, protected.
//            •	public обеспечивает доступ к членам класса извне класса, private делает члены доступными только внутри класса, а protected делает их доступными для классов - наследников.
//            •	Пример определения класса с различными областями видимости :
//        class MyClass {
//        public:    // Область общего доступа
//            int publicVar;
//
//        private:   // Область закрытого доступа
//            int privateVar;
//
//        protected: // Область доступа в пределах наследования
//            int protectedVar;
//
//        public:
//            // Метод для доступа к закрытому члену
//            void setPrivateVar(int value) {
//                privateVar = value;
//            }
//        };
//        Опережающее определение класса :
//        •	В C++, можно использовать опережающее определение класса(forward declaration), когда необходимо указать компилятору о существовании класса до его фактического определения.
//            •	Это полезно, например, при взаимной зависимости классов или при объявлении указателей или ссылок на класс, когда определение класса будет предоставлено позднее.
//            •	Пример опережающего определения класса :
//        class MyClass; // Опережающее определение класса
//
//        class AnotherClass {
//        public:
//            MyClass* ptrToMyClass; // Использование указателя на MyClass
//        };
//        Это позволяет компилятору знать о существовании класса MyClass, но его определение может быть предоставлено позже.
//            Вопрос 17. Использование спецификатора класса памяти static.Статические компоненты класса.
//            Спецификатор static в контексте класса в C++ имеет несколько особенностей :
//        1.	Статические данные класса(статические переменные) : Статические переменные класса общие для всех объектов этого класса.Они существуют в единственном экземпляре, независимо от количества созданных объектов.Они обычно инициализируются за пределами методов класса и используются для хранения общей информации для всех экземпляров класса.
//            class MyClass {
//            public:
//                static int staticVar; // Объявление статической переменной класса
//        };
//
//        // Инициализация статической переменной вне класса
//        int MyClass::staticVar = 0;
//
//        int main() {
//            MyClass obj1, obj2;
//
//            // Обращение к статической переменной через класс
//            MyClass::staticVar = 10;
//
//            // Обращение к статической переменной через объекты класса
//            obj1.staticVar = 20;
//            obj2.staticVar = 30;
//
//            cout << MyClass::staticVar << endl; // Вывод: 30
//            return 0;
//        }
//        2.	Статические методы класса : Статические методы класса не имеют доступа к нестатическим данным класса(без использования объектов класса) и могут вызываться без создания экземпляра класса.Они часто используются для выполнения операций, связанных с классом, но не требующих доступа к конкретным объектам.
//            class MyClass {
//            public:
//                static void staticMethod() {
//                    cout << "This is a static method" << endl;
//                }
//        };
//
//        int main() {
//            MyClass::staticMethod(); // Вызов статического метода без объекта класса
//            return 0;
//        }
//        Статические компоненты класса позволяют работать с данными и методами, общими для всех объектов класса, без необходимости создания экземпляра класса.Они полезны для хранения данных, которые должны быть общими для всех объектов, или для выполнения операций, не связанных с конкретными экземплярами класса.
//            Вопрос 18. Константные объекты и константные методы.
//            Константные объекты :
//        •	Константный объект — это объект, который не может изменять свои члены данных после создания.
//            •	Константный объект класса можно создать, используя ключевое слово const.
//            Пример :
//            class MyClass {
//            public:
//                int data;
//        };
//
//        int main() {
//            const MyClass obj; // Константный объект
//
//            // obj.data = 5; // Ошибка: попытка изменить константный объект
//            return 0;
//        }
//        Константные методы :
//        •	Константные методы — это методы класса, которые гарантируют, что они не изменят состояние объекта.
//            •	Для объявления константного метода используется ключевое слово const после списка параметров метода.
//            Пример :
//            class MyClass {
//            public:
//                int data;
//
//                void regularMethod() {
//                    data = 10; // Разрешено изменение данных внутри обычного метода
//                }
//
//                void constMethod() const {
//                    // data = 20; // Ошибка: попытка изменить данные в константном методе
//                }
//        };
//        Константные методы полезны, когда нужно обеспечить, чтобы метод не менял состояние объекта.Они также позволяют использовать объекты как аргументы для других функций, где требуется гарантия, что объект не будет изменен.
//            Константные объекты и методы вместе обеспечивают дополнительный уровень безопасности и гарантируют, что данные объекта не будут изменены случайно или намеренно.
//            Вопрос 19. Неявный указатель this
//            this — это указатель на текущий объект в C++.Он используется внутри методов класса для доступа к членам этого объекта.Он является скрытым параметром, который передается каждому методу класса и указывает на объект, для которого вызывается данный метод.
//            Пример использования this:
//        class MyClass {
//        private:
//            int value;
//
//        public:
//            MyClass(int val) : value(val) {}
//
//            void printValue() {
//                cout << "Value: " << this->value << endl; // Использование указателя this
//            }
//
//            void compareValue(int x) {
//                if (x == this->value) {
//                    cout << "Match!" << endl;
//                }
//                else {
//                    cout << "No match!" << endl;
//                }
//            }
//        };
//
//        int main() {
//            MyClass obj1(5), obj2(10);
//
//            obj1.printValue(); // Выведет "Value: 5"
//            obj2.compareValue(10); // Выведет "Match!"
//
//            return 0;
//        }
//        this позволяет избежать неоднозначности при работе с членами класса, особенно когда имена параметров метода совпадают с именами членов класса.Он обеспечивает доступ к членам объекта, на котором вызывается метод.
//            Обычно использование this не является обязательным, поскольку компилятор обрабатывает доступ к членам класса без явного указания this.Однако, в некоторых случаях, например, при работе с указателями или при разрешении конфликтов имен, явное использование this может быть полезным.
//            Вопрос 20. Указатели на член класса.
//            Указатели на члены класса в C++ позволяют обращаться к членам класса через указатель на объект или указатель на тип данных класса.Они позволяют динамически определять, к какому члену класса следует обратиться.
//            Синтаксис указателей на члены класса :
//        class MyClass {
//        public:
//            int data1;
//            double data2;
//        };
//
//        int main() {
//            int MyClass::* ptr1;    // Указатель на int-член класса
//            double MyClass::* ptr2; // Указатель на double-член класса
//
//            ptr1 = &MyClass::data1; // Присваивание адреса члена класса указателю
//            ptr2 = &MyClass::data2;
//
//            MyClass obj;
//            obj.*ptr1 = 10; // Доступ к члену класса через указатель
//            obj.*ptr2 = 3.14;
//
//            cout << "data1: " << obj.data1 << endl; // Вывод: data1: 10
//            cout << "data2: " << obj.data2 << endl; // Вывод: data2: 3.14
//
//            return 0;
//        }
//        Здесь int MyClass::* ptr1 - указатель на член класса int, а double MyClass::* ptr2 - указатель на член класса double.С помощью оператора.*можно обратиться к членам класса через указатель.
//            Эти указатели могут быть полезны для создания гибкого и универсального кода, где члены класса могут выбираться или изменяться во время выполнения программы в зависимости от определенных условий или сценариев.Они также могут использоваться для создания таблиц указателей на функции - члены класса или для реализации механизмов обратного вызова.
//            Вопрос 21. Локальные и вложенные классы.
//            Локальные и вложенные классы в C++ представляют собой классы, определенные внутри других классов или функций.
//            Локальные классы :
//        •	Локальные классы - это классы, определенные внутри функций.Они имеют доступ к области видимости функции, в которой они определены.
//            •	Они могут обращаться к переменным и параметрам функции, в которой они находятся, в том числе к локальным переменным.
//            Пример локального класса :
//        void someFunction() {
//            int localVar = 10;
//
//            class LocalClass {
//            public:
//                void displayLocalVar() {
//                    cout << "LocalVar: " << localVar << endl; // Доступ к локальной переменной
//                }
//            };
//
//            LocalClass obj;
//            obj.displayLocalVar();
//        }
//        Вложенные классы :
//        •	Вложенные классы - это классы, определенные внутри другого класса.Они имеют доступ ко всем членам внешнего класса, включая закрытые и защищенные члены.
//            Пример вложенного класса :
//        class OuterClass {
//        private:
//            int privateVar;
//
//        public:
//            class NestedClass {
//            public:
//                void displayPrivateVar(OuterClass& obj) {
//                    cout << "PrivateVar: " << obj.privateVar << endl; // Доступ к закрытому члену внешнего класса
//                }
//            };
//        };
//        Оба типа классов(локальные и вложенные) улучшают организацию кода, обеспечивая логическую группировку и уменьшая возможность конфликтов имен, так как их области видимости ограничены контекстом, в котором они определены.
//            Вопрос 22. Специальный вид методов класса – конструкторы и деструкторы.Некоторые особенности конструкторов и деструкторов.
//            Конструкторы и деструкторы - это специальные методы класса, предназначенные для инициализации и очистки ресурсов объекта соответственно.
//            Конструкторы:
//        •	Конструкторы - это методы класса, вызываемые при создании объекта.
//            •	Их имя совпадает с именем класса и могут быть перегружены для поддержки различных вариантов инициализации объекта(с разными параметрами, например).
//            •	Конструкторы могут выполнять инициализацию членов класса, выделение ресурсов и другие операции для подготовки объекта к использованию.
//            •	Конструктор по умолчанию(без параметров) вызывается, когда объект создается без явного указания конструктора для инициализации.
//            Пример конструкторов :
//        class MyClass {
//        public:
//            int data;
//
//            // Конструктор по умолчанию
//            MyClass() {
//                data = 0;
//                cout << "Default constructor called" << endl;
//            }
//
//            // Пользовательский конструктор
//            MyClass(int value) {
//                data = value;
//                cout << "Parameterized constructor called" << endl;
//            }
//        };
//    Деструкторы:
//        •	Деструкторы - это методы класса, вызываемые при уничтожении объекта.
//            •	Их имя начинается с тильды ~и имеет тот же самый идентификатор, что и класс.
//            •	Деструкторы используются для освобождения ресурсов, занимаемых объектом, и выполнения других операций перед его удалением из памяти.
//            •	Они не принимают параметров и не возвращают значений.
//            Пример деструктора :
//        class MyClass {
//        public:
//            int* data;
//
//            MyClass() {
//                data = new int[10]; // Выделение памяти
//                cout << "Constructor called" << endl;
//            }
//
//            ~MyClass() {
//                delete[] data; // Освобождение памяти
//                cout << "Destructor called" << endl;
//            }
//        };
//    Особенности:
//        •	У класса может быть только один деструктор, но может быть несколько конструкторов(в том числе перегруженных).
//            •	Деструктор вызывается автоматически при выходе объекта из области видимости или при явном удалении объекта с помощью оператора delete.
//            •	Конструкторы и деструкторы выполняют важную роль в управлении памятью и ресурсами объекта, обеспечивая их корректное создание и уничтожение.
//            Вопрос 23. Программирование методов.Программирование методов и принцип модульности.Представление алгоритмической компоненты класса в виде множества мелких методов, вызывающих друг друга.Создание вспомогательных локальных объектов при выполнении операций над основными объектами класса.
//            Программирование методов класса и принцип модульности в ООП подразумевают организацию функциональности класса через множество мелких методов, каждый из которых выполняет отдельную задачу.Такой подход упрощает понимание и поддержку кода, делая его более модульным и гибким.
//            Принцип модульности в программировании методов класса :
//        •	Каждый метод класса должен выполнять одну конкретную задачу или операцию.
//            •	Модульные методы упрощают отладку и тестирование, поскольку они выполняют ограниченные и четко определенные задачи.
//            •	Разделение функциональности на маленькие методы позволяет повторно использовать код и делает его более поддерживаемым.
//            Пример модульных методов класса :
//        class Calculation {
//        public:
//            double add(double a, double b) {
//                return a + b;
//            }
//
//            double subtract(double a, double b) {
//                return a - b;
//            }
//
//            double multiply(double a, double b) {
//                return a * b;
//            }
//
//            double divide(double a, double b) {
//                if (b == 0) {
//                    cout << "Error: Division by zero!" << endl;
//                    return 0;
//                }
//                return a / b;
//            }
//        };
//        Создание вспомогательных локальных объектов :
//        •	При выполнении операций над основными объектами класса, иногда полезно создавать вспомогательные локальные объекты для выполнения определенных задач.
//            •	Это помогает уменьшить сложность методов, разбивая их на более мелкие и управляемые части.
//            Пример использования вспомогательных объектов :
//        class Vector {
//        private:
//            int x, y;
//
//        public:
//            Vector(int a, int b) : x(a), y(b) {}
//
//            int dotProduct(const Vector& other) {
//                return x * other.x + y * other.y;
//            }
//
//            double magnitude() {
//                return sqrt(x * x + y * y);
//            }
//        };
//        В этом примере методы dotProduct и magnitude используются для вычисления скалярного произведения векторов и длины вектора соответственно, разделяя задачи на меньшие функциональные блоки для повышения читаемости и модульности кода.
//            Использование мелких методов, вызывающих друг друга и создание вспомогательных локальных объектов при выполнении операций над основными объектами класса, способствует более понятному и управляемому коду.
//            Вопрос 24. Программирование методов.Способы передачи параметров в методы.Конвейер ссылок и конвейер значений.
//            Передача параметров в методы класса в C++ может осуществляться различными способами, включая конвейер значений(передача по значению) и конвейер ссылок(передача по ссылке).
//            Конвейер значений(передача по значению) :
//            •	При передаче параметров по значению создается копия передаваемого значения и используется эта копия в методе.
//            •	Изменения, внесенные в копию, не отразятся на исходном объекте, так как метод работает с копией параметра.
//            •	Передача по значению особенно полезна, когда необходимо избежать изменения исходного объекта.
//            Пример передачи по значению :
//        class MyClass {
//        public:
//            void setValue(int val) {
//                // val - копия переданного значения
//                // Изменения в val не повлияют на исходный аргумент
//            }
//        };
//
//        int main() {
//            MyClass obj;
//            int value = 10;
//            obj.setValue(value); // Передача значения по значению
//            return 0;
//        }
//        Конвейер ссылок(передача по ссылке) :
//            •	Передача параметров по ссылке позволяет методу работать с самим объектом, а не его копией.
//            •	Изменения, внесенные в параметры метода, напрямую отразятся на исходном объекте, так как метод работает с ссылкой на этот объект.
//            Пример передачи по ссылке :
//        class MyClass {
//        public:
//            void setValueByReference(int& val) {
//                // val - ссылка на переданный аргумент
//                // Изменения в val отразятся на исходном аргументе
//            }
//        };
//
//        int main() {
//            MyClass obj;
//            int value = 10;
//            obj.setValueByReference(value); // Передача значения по ссылке
//            return 0;
//        }
//        Выбор между передачей по значению и по ссылке зависит от ситуации.Передача по ссылке может быть более эффективной для больших объектов, так как избегается создание копии.Однако передача по значению часто более безопасна и предсказуема, особенно когда не требуется изменение исходного объекта.
//            Вопрос 25. Классы, содержащие объекты других классов
//            Классы в C++ могут содержать объекты других классов в качестве своих членов.Это называется композицией и позволяет создавать более сложные структуры данных, объединяя объекты различных классов внутри других классов.
//            Пример композиции :
//        class Engine {
//        public:
//            void start() {
//                // Реализация запуска двигателя
//            }
//        };
//
//        class Car {
//        private:
//            Engine carEngine; // Объект класса Engine внутри класса Car
//
//        public:
//            void startCar() {
//                carEngine.start(); // Использование метода start из класса Engine
//                // Дополнительные действия для запуска автомобиля
//            }
//        };
//        В этом примере класс Car содержит объект класса Engine в качестве своего члена.Это означает, что объект класса Car имеет доступ ко всем методам и членам объекта carEngine.
//            Композиция позволяет создавать иерархии классов, где более высокоуровневые классы содержат в себе объекты более низкоуровневых классов, что способствует организации и модульности кода.Кроме того, это обеспечивает возможность использования множества маленьких классов для создания более сложных и функциональных объектов.
//            Вопрос 26. Создание объектов с различным временем жизни
//            Объекты в C++ могут иметь разное время жизни в зависимости от того, как они создаются :
//        1.	Статические объекты : Они создаются во время выполнения программы до того, как начнется выполнение функции main(), и существуют до завершения программы.Их время жизни соответствует времени работы программы.
//            class MyClass {
//            public:
//                MyClass() {
//                    cout << "Constructor called" << endl;
//                }
//
//                ~MyClass() {
//                    cout << "Destructor called" << endl;
//                }
//        };
//
//        // Статический объект
//        MyClass staticObj;
//
//        int main() {
//            cout << "Inside main()" << endl;
//            return 0;
//        }
//        2.	Автоматические объекты : они создаются при входе в блок кода и уничтожаются при выходе из этого блока.Их время жизни ограничено областью видимости, в которой они были объявлены.
//            int main() {
//                {
//                    MyClass automaticObj; // Автоматический объект
//                } // automaticObj уничтожается при выходе из этого блока
//                return 0;
//        }
//        3.	Динамические объекты : создаются и уничтожаются во время выполнения программы с помощью операторов new и delete.Их время жизни управляется программистом и не ограничено областью видимости.
//            int main() {
//            MyClass* dynamicObj = new MyClass(); // Динамический объект
//            delete dynamicObj; // Уничтожение динамического объекта
//
//            return 0;
//        }
//        Вопрос 27. Массивы объектов класса
//            Для создания массивов объектов класса в C++ используется синтаксис аналогичный созданию массивов других типов данных.Это позволяет создавать и управлять несколькими объектами одного класса.
//            Пример создания массива объектов класса :
//        class MyClass {
//        public:
//            void someMethod() {
//                // Реализация метода
//            }
//        };
//
//        int main() {
//            const int size = 5;
//            MyClass array[size]; // Создание массива объектов класса MyClass
//
//            for (int i = 0; i < size; ++i) {
//                array[i].someMethod(); // Обращение к методу объекта массива
//            }
//
//            return 0;
//        }
//        Здесь массив array содержит пять объектов класса MyClass.Каждый из объектов можно использовать так же, как и любой другой объект этого класса : вызывать его методы, обращаться к его членам и т.д.
//            Объекты массива создаются в памяти последовательно друг за другом и их расположение в памяти аналогично расположению элементов в обычных массивах других типов данных.
//            Важно учитывать, что при создании массива объектов класса вызываются конструкторы по умолчанию для каждого элемента массива, если они определены в классе.Также деструкторы будут вызваны при выходе из области видимости массива или при вызове оператора delete[], если массив создан динамически.
//            Вопрос 28. Особенности копирования объектов
//            1.	Конструктор копирования :
//        •	Конструктор копирования создает новый объект на основе существующего объекта того же класса.
//            •	Обычно используется при передаче объектов в функции по значению или при инициализации одного объекта другим.
//            class MyClass {
//            public:
//                int data;
//
//                // Конструктор копирования
//                MyClass(const MyClass& other) {
//                    data = other.data; // Копирование данных из другого объекта
//                }
//        };
//        2.	Оператор присваивания(operator=) :
//            •	Оператор присваивания позволяет копировать данные из одного объекта в другой объект того же класса.
//            •	Проверка на самоприсваивание(if (this != &other)) важна для предотвращения проблемы, когда объект присваивает самому себе.
//            class MyClass {
//            public:
//                int data;
//
//                // Оператор присваивания
//                MyClass& operator=(const MyClass& other) {
//                    if (this != &other) { // Проверка на самоприсваивание
//                        data = other.data; // Копирование данных из другого объекта
//                    }
//                    return *this;
//                }
//        };
//        3.	Поверхностное копирование vs глубокое копирование :
//        •	При использовании динамического выделения памяти объекты могут содержать указатели на динамические данные.При копировании необходимо определить, требуется ли создание копии самих данных(глубокое копирование) или только копирование указателей(поверхностное копирование).
//            •	В случае глубокого копирования необходимо создавать новые динамические объекты и копировать данные из одного объекта в другой.
//            class DynamicData {
//            public:
//                int* data;
//
//                DynamicData(const DynamicData& other) {
//                    data = new int(*other.data); // Глубокое копирование
//                }
//
//                ~DynamicData() {
//                    delete data; // Освобождение выделенной памяти
//                }
//        };
//        Корректное копирование объектов важно для избегания утечек памяти, сохранения целостности данных и предотвращения проблем с управлением ресурсами.
//            Вопрос 29. Заготовка класса без наследника
//            Пример базового класса без наследников :
//        class BaseClass {
//        public:
//            BaseClass() {
//                // Конструктор базового класса
//            }
//
//            // Деструктор может быть виртуальным, если планируется наследование
//            virtual ~BaseClass() {
//                // Деструктор базового класса
//            }
//
//            // Другие методы и члены класса могут быть добавлены здесь
//        };
//        В этом примере BaseClass представляет собой базовый класс без явно определенных наследников.Он может содержать виртуальный деструктор, что может быть полезно, если класс будет использоваться в иерархии наследования для корректного удаления объектов даже через указатель на базовый класс.
//            Этот класс может содержать методы и переменные, которые могут быть общими для всех классов, наследующих от него.Кроме того, он может служить основой для создания других классов путем наследования от него.
//            Вопрос 30. Пример вектора с не поверхностным копированием
//            Концепция вектора с не поверхностным копированием подразумевает создание объекта, который содержит динамически выделенные ресурсы(например, массив) и управляет ими таким образом, чтобы при копировании объекта создавалась глубокая копия этих ресурсов, а не просто копия указателя на них.
//            Вот пример простого вектора, демонстрирующего не поверхностное копирование с использованием динамического выделения памяти для массива элементов :
//#include <iostream>
//
//        class Vector {
//        private:
//            int size;
//            int* elements;
//
//        public:
//            Vector(int sz) : size(sz) {
//                elements = new int[size]; // Выделение памяти под элементы вектора
//            }
//
//            // Конструктор копирования для глубокого копирования элементов
//            Vector(const Vector& other) : size(other.size) {
//                elements = new int[size];
//                for (int i = 0; i < size; ++i) {
//                    elements[i] = other.elements[i]; // Глубокое копирование элементов
//                }
//            }
//
//            // Оператор присваивания для глубокого копирования элементов
//            Vector& operator=(const Vector& other) {
//                if (this != &other) { // Проверка на самоприсваивание
//                    delete[] elements; // Очистка текущих элементов
//                    size = other.size;
//                    elements = new int[size];
//                    for (int i = 0; i < size; ++i) {
//                        elements[i] = other.elements[i]; // Глубокое копирование элементов
//                    }
//                }
//                return *this;
//            }
//
//            // Деструктор для освобождения памяти
//            ~Vector() {
//                delete[] elements; // Освобождение памяти
//            }
//
//            // Другие методы для работы с вектором могут быть добавлены здесь
//        };
//        Вопрос 31. Излишнее копирование.Конструктор копии.Операция присваивания.
//            Излишнее копирование может возникать при работе с конструкторами копирования и операторами присваивания, когда данные копируются чаще, чем необходимо или без необходимости.Это может привести к избыточному использованию ресурсов и снижению производительности программы.
//            Конструктор копии :
//        •	Конструктор копии создает новый объект, копируя данные из существующего объекта того же класса.
//            •	Излишнее копирование возникает, когда копируются данные, которые не нужны для корректной работы нового объекта.
//            •	Например, если класс содержит динамически выделенные ресурсы, неправильно реализованный конструктор копии может привести к повторному выделению памяти.
//            Операция присваивания :
//        •	Оператор присваивания(operator=) копирует данные одного объекта в другой объект того же класса.
//            •	Подобно конструктору копии, излишнее копирование может возникнуть, если копируются данные, которые не должны быть скопированы.
//            Пример излишнего копирования :
//        class MyClass {
//        private:
//            int* data;
//
//        public:
//            // Конструктор копии
//            MyClass(const MyClass& other) {
//                data = new int(*other.data); // Глубокое копирование данных
//            }
//
//            // Оператор присваивания
//            MyClass& operator=(const MyClass& other) {
//                if (this != &other) {
//                    delete data; // Освобождение текущих данных
//                    data = new int(*other.data); // Глубокое копирование данных
//                }
//                return *this;
//            }
//        };
//        В этом примере при каждом копировании объекта происходит глубокое копирование данных, что может быть излишним, если данные не изменяются или если это излишне для работы нового объекта.Избежать излишнего копирования можно, оптимизировав копирование только необходимых данных или используя семантику перемещения(move semantics), если это возможно для вашего класса.
//            Вопрос 32. Преобразование типов.Стандартное преобразование.Явное преобразование.
//            В C++ есть несколько способов преобразования типов :
//        1.	Стандартное(неявное) преобразование типов :
//        •	Это автоматическое преобразование типов, выполняемое компилятором без явного указания программистом.
//            •	Например, если вы присваиваете значение меньшего типа переменной большего типа, компилятор выполнит преобразование.
//            int a = 10;
//        double b = a; // Стандартное преобразование int в double
//        2.	Явное преобразование типов :
//        •	Это преобразование типов, указываемое явно программистом.
//            •	Это может быть выполнено с помощью операторов static_cast, dynamic_cast, const_cast, reinterpret_cast или с использованием функций - преобразователей.
//            Примеры :
//            double c = 3.14;
//        int d = static_cast<int>(c); // Явное преобразование double в int
//
//        const int* ptr = nullptr;
//        int* mutablePtr = const_cast<int*>(ptr); // Снятие константности указателя
//        3.	Пользовательские преобразования :
//        •	В C++ есть возможность определения пользовательских преобразований типов с помощью конструкторов с одним параметром или операторов преобразования.
//            class Distance {
//            private:
//                int feet;
//
//            public:
//                Distance(int ft) : feet(ft) {}
//
//                operator int() const {
//                    return feet;
//                }
//        };
//
//        int main() {
//            Distance dist(5);
//            int feetValue = static_cast<int>(dist); // Пользовательское преобразование
//            return 0;
//        }
//        Стандартное преобразование происходит автоматически, что может привести к потере данных или неожиданным результатам.Явное преобразование дает программисту больше контроля над процессом преобразования типов и обеспечивает более явное и понятное поведение программы.
//            Вопрос 33. Преобразование абстрактных типов данных(преобразование типов данных, созданных программистом)
//            Преобразование абстрактных типов данных в С++ - это конвертация между различными пользовательскими типами данных или классами, созданными программистом.Это может включать в себя как стандартные преобразования, так и пользовательские методы преобразования.
//            Есть несколько способов выполнения преобразования пользовательских типов :
//        1.	Явное преобразование :
//        •	Это преобразование типов, выполняемое с помощью явных операторов преобразования, таких как static_cast, dynamic_cast, reinterpret_cast, const_cast.
//            •	Преобразование может происходить между различными пользовательскими типами данных, если есть соответствующие операторы преобразования или конструкторы для таких преобразований.
//            Пример :
//            class Distance {
//            private:
//                int feet;
//
//            public:
//                Distance(int ft) : feet(ft) {}
//
//                operator int() const {
//                    return feet;
//                }
//        };
//
//        int main() {
//            Distance dist(5);
//            int feetValue = static_cast<int>(dist); // Явное преобразование пользовательского типа
//            return 0;
//        }
//        2.	Оператор преобразования(operator conversion) :
//            •	Это пользовательский оператор, определенный в классе, который позволяет преобразовывать объект этого класса в другой тип данных.
//            •	Оператор преобразования перегружается как часть класса и позволяет выполнить преобразование объекта класса в другой тип данных.
//            Пример :
//            class Distance {
//            private:
//                int feet;
//
//            public:
//                Distance(int ft) : feet(ft) {}
//
//                operator int() const {
//                    return feet;
//                }
//        };
//
//        int main() {
//            Distance dist(5);
//            int feetValue = dist; // Использование оператора преобразования
//            return 0;
//        }
//        Эти методы позволяют программисту определить способы преобразования пользовательских типов данных в различные типы данных в соответствии с требованиями программы.Однако следует быть осторожным и избегать ненужных или потенциально опасных преобразований, которые могут привести к неоднозначности или потере данных.
//            Вопрос 34. Наследование классов
//            Наследование классов — это ключевой механизм в объектно - ориентированном программировании, позволяющий создавать новый класс на основе существующего класса, наследуя его свойства и функциональность.
//            Виды наследования в C++:
//        1.	Публичное наследование :
//        •	class DerivedClass : public BaseClass {}
//        •	Публичное наследование делает публичные члены базового класса доступными в производном классе как публичные члены.
//            •	Остальные типы членов(защищенные и приватные) остаются соответственно защищенными и приватными в производном классе.
//            2.	Защищенное наследование :
//        •	class DerivedClass : protected BaseClass {}
//        •	Защищенное наследование делает публичные и защищенные члены базового класса защищенными в производном классе.
//            •	Приватные члены остаются приватными.
//            3.	Приватное наследование :
//        •	class DerivedClass : private BaseClass {}
//        •	Приватное наследование делает все члены базового класса приватными в производном классе.
//            •	Это самый строгий вид наследования, когда все члены базового класса доступны только внутри производного класса.
//            Пример :
//            class Base {
//            public:
//                void baseFunction() {
//                    std::cout << "Base function" << std::endl;
//                }
//        };
//
//        class Derived : public Base {
//        public:
//            void derivedFunction() {
//                std::cout << "Derived function" << std::endl;
//            }
//        };
//
//        int main() {
//            Derived derivedObj;
//            derivedObj.baseFunction(); // Доступ к методу базового класса через объект производного класса
//            derivedObj.derivedFunction(); // Вызов метода производного класса
//            return 0;
//        }
//        Этот пример показывает, как происходит наследование методов из базового класса Base в производный класс Derived, позволяя объекту Derived использовать методы и члены данных, определенные в классе Base.
//            Вопрос 35. Доступ к наследуемым членам класса
//            Доступ к наследуемым членам класса зависит от уровня доступа, указанного при наследовании.В C++ есть три уровня доступа при наследовании : public, protected и private.
//            1.	Public inheritance(публичное наследование) :
//            •	Публичные члены базового класса остаются публичными в производном классе.
//            •	Защищенные и приватные члены базового класса становятся, соответственно, защищенными и приватными в производном классе.
//            •	Объекты производного класса имеют доступ к публичным членам базового класса.
//            class Base {
//            public:
//                int publicVar;
//                void publicFunction() {}
//        };
//
//        class Derived : public Base {
//        public:
//            void someFunction() {
//                publicVar = 10; // Доступ к публичной переменной базового класса
//                publicFunction(); // Доступ к публичной функции базового класса
//            }
//        };
//        2.	Protected inheritance(защищенное наследование) :
//            •	Публичные и защищенные члены базового класса становятся защищенными в производном классе.
//            •	Приватные члены остаются недоступными вне класса.
//            class Base {
//            protected:
//                int protectedVar;
//                void protectedFunction() {}
//        };
//
//        class Derived : protected Base {
//        public:
//            void someFunction() {
//                protectedVar = 10; // Доступ к защищенной переменной базового класса
//                protectedFunction(); // Доступ к защищенной функции базового класса
//            }
//        };
//        3.	Private inheritance(приватное наследование) :
//            •	Все члены базового класса становятся приватными в производном классе.
//            •	Члены базового класса доступны только внутри производного класса.
//            class Base {
//            private:
//                int privateVar;
//                void privateFunction() {}
//        };
//
//        class Derived : private Base {
//        public:
//            void someFunction() {
//                privateVar = 10; // Доступ к приватной переменной базового класса
//                privateFunction(); // Доступ к приватной функции базового класса
//            }
//        };
//        Правильное использование уровней доступа при наследовании важно для обеспечения безопасности и организации доступа к членам класса в соответствии с логикой вашей программы.
//            Вопрос 36. Стандартные преобразования типов при наследовании
//            При наследовании в С++ применяются стандартные правила преобразования типов.Они определяют, как типы преобразуются при использовании в контексте наследования.
//            1.	Преобразование указателей :
//        •	При наследовании указатель на производный класс может быть преобразован в указатель на базовый класс без явного преобразования.
//            •	Обратное преобразование требует явного приведения типов.
//            class Base {};
//        class Derived : public Base {};
//
//        Derived d;
//        Base* ptrBase = &d; // Преобразование указателя на Derived в указатель на Base
//        2.	Преобразование ссылок :
//        •	При наследовании ссылка на производный класс может быть преобразована в ссылку на базовый класс без явного преобразования.
//            •	Обратное преобразование требует явного приведения типов.
//            class Base {};
//        class Derived : public Base {};
//
//        Derived d;
//        Base& refBase = d; // Преобразование ссылки на Derived в ссылку на Base
//        3.	Преобразование объектов :
//        •	Преобразование объектов из производного класса в базовый класс выполняется автоматически.
//            •	Обратное преобразование(от базового к производному) требует использования динамического приведения типов(dynamic_cast или static_cast) и проверки на корректность преобразования.
//            class Base {
//            public:
//                virtual ~Base() {} // Виртуальный деструктор для полиморфных классов
//        };
//
//        class Derived : public Base {};
//
//        Base* ptrBase = new Derived(); // Преобразование объекта Derived в объект Base
//        delete ptrBase;
//        Стандартные правила преобразования типов при наследовании обеспечивают безопасное использование указателей, ссылок и объектов различных классов в иерархии наследования.Однако необходимо следить за корректностью приведения типов и использовать динамическое приведение там, где это необходимо, чтобы избежать ошибок времени выполнения.
//            Вопрос 37. Инициализация объекта порожденного класса.Конструктор копии.Операция присваивания.
//            При создании объекта порожденного класса в С++ происходит инициализация сначала базового класса, а затем порожденного класса.Конструктор базового класса вызывается до конструктора порожденного класса.
//            Пример:
//        class Base {
//        public:
//            Base() {
//                // Конструктор базового класса
//            }
//        };
//
//        class Derived : public Base {
//        public:
//            Derived() {
//                // Конструктор порожденного класса
//            }
//        };
//
//        int main() {
//            Derived derivedObj; // Создание объекта порожденного класса
//            return 0;
//        }
//        При инициализации объекта Derived, сначала вызывается конструктор Base, затем конструктор Derived.После выполнения конструктора базового класса запускается конструктор порожденного класса.
//            Что касается конструктора копии и оператора присваивания, они могут быть определены как в базовом, так и в порожденном классах.Если они не определены в порожденном классе, будет использоваться версия из базового класса.
//            Конструктор копии создает копию существующего объекта, а оператор присваивания копирует данные одного объекта в другой.Если для класса не определены собственные конструктор копии и оператор присваивания, компилятор предоставит автоматически сгенерированные версии для выполнения поверхностного копирования данных.
//            Пользовательские версии конструктора копии и оператора присваивания могут быть определены, чтобы обеспечить глубокое копирование данных, освобождение ресурсов и т.д., в зависимости от потребностей вашего класса.
//            Вопрос 38. Множественное наследование.Двусмысленности при множественном наследовании.Виртуальные базовые классы.Инициализация виртуального базового класса.Порядок вызовов конструкторов и деструкторов в случае нескольких базовых классов.
//            Множественное наследование в C++ позволяет классу наследоваться от нескольких классов - родителей.Это может привести к некоторым особенностям и двусмысленностям, особенно когда возникают конфликты имен или двусмысленности при обращении к членам класса.
//            Двусмысленность при множественном наследовании возникает, когда происходит конфликт имен или методов между различными базовыми классами.Например, если производный класс унаследовал метод с одинаковым именем и параметрами из нескольких базовых классов, может возникнуть неоднозначность при вызове этого метода из производного класса.
//            Виртуальные базовые классы используются для предотвращения создания нескольких копий одного и того же базового класса в случае множественного наследования.Если класс является виртуальным базовым классом, то только одна копия этого класса будет существовать в иерархии наследования.
//            Инициализация виртуального базового класса происходит через цепочку конструкторов.Конструкторы каждого класса - предка вызываются в порядке наследования.
//            Порядок вызовов конструкторов и деструкторов в случае нескольких базовых классов :
//        1.	Конструкторы :
//            •	Конструкторы базовых классов вызываются в порядке, определенном списком наследования в определении производного класса.
//            •	Виртуальные базовые классы вызываются только один раз в цепочке конструкторов.
//            2.	Деструкторы :
//            •	Деструкторы вызываются в обратном порядке, начиная с конечного класса в цепочке наследования.
//            •	Виртуальные базовые классы вызываются последними в цепочке деструкторов.
//            Пример :
//#include <iostream>
//
//            class Base1 {
//            public:
//                Base1() { std::cout << "Constructor of Base1" << std::endl; }
//                ~Base1() { std::cout << "Destructor of Base1" << std::endl; }
//        };
//
//        class Base2 {
//        public:
//            Base2() { std::cout << "Constructor of Base2" << std::endl; }
//            ~Base2() { std::cout << "Destructor of Base2" << std::endl; }
//        };
//
//        class Derived : public Base1, public Base2 {
//        public:
//            Derived() { std::cout << "Constructor of Derived" << std::endl; }
//            ~Derived() { std::cout << "Destructor of Derived" << std::endl; }
//        };
//
//        int main() {
//            Derived derivedObj;
//            return 0;
//        }
//        В результате создания объекта Derived вызовутся конструкторы Base1, Base2, и Derived в указанном порядке, а при уничтожении объекта - деструкторы в обратном порядке : Derived, Base2, Base1.
//            Вопрос 39. Виртуальные функции.Объявление виртуальных функций.Чисто виртуальные функции.
//            Виртуальные функции — это ключевой механизм в объектно - ориентированном программировании, позволяющий переопределять методы в производных классах.Они обеспечивают полиморфизм, что позволяет вызывать функцию производного класса через указатель на базовый класс.
//            Объявление виртуальной функции :
//        •	Виртуальная функция объявляется с помощью ключевого слова virtual в базовом классе.
//            •	Производные классы могут переопределять эту функцию с помощью того же ключевого слова virtual или без него(виртуальная функция в производном классе автоматически становится виртуальной, если она переопределяет виртуальную функцию базового класса).
//            class Base {
//            public:
//                virtual void display() {
//                    std::cout << "Display from Base class" << std::endl;
//                }
//        };
//
//        class Derived : public Base {
//        public:
//            void display() override { // Переопределение виртуальной функции
//                std::cout << "Display from Derived class" << std::endl;
//            }
//        };
//        Чисто виртуальные функции(абстрактные функции) :
//            •	Чисто виртуальная функция — это виртуальная функция без тела, объявленная в базовом классе и предназначенная для переопределения в производных классах.
//            •	Класс, содержащий хотя бы одну чисто виртуальную функцию, становится абстрактным классом и не может быть использован для создания объектов.
//            class AbstractBase {
//            public:
//                virtual void pureVirtualFunction() = 0; // Чисто виртуальная функция
//        };
//
//        class ConcreteDerived : public AbstractBase {
//        public:
//            void pureVirtualFunction() override {
//                std::cout << "Implemented pure virtual function" << std::endl;
//            }
//        };
//        Чисто виртуальные функции полезны для создания интерфейсов : они определяют обязательные методы, которые должны быть реализованы в производных классах, обеспечивая единый интерфейс для различных реализаций.
//            Вопрос 40. Таблица виртуальных функций.Случаи, когда вызов виртуальной функции не будет виртуальным.Виртуальные деструкторы.
//            Таблица виртуальных функций(V - table) — это механизм, используемый компилятором для реализации динамического связывания виртуальных функций.Каждый объект класса с виртуальными функциями содержит указатель на таблицу виртуальных функций.В этой таблице содержатся адреса виртуальных функций для этого класса и его предков.
//            Когда вызывается виртуальная функция через указатель на базовый класс, компилятор использует V - table объекта, чтобы определить, какая именно функция должна быть вызвана, в зависимости от типа объекта в момент выполнения программы.
//            Случаи, когда вызов виртуальной функции не будет виртуальным :
//        1.	Когда функция вызывается через объект, а не через указатель или ссылку :
//        •	Если функция вызывается напрямую через объект класса, а не через указатель или ссылку, компилятор будет использовать статическую привязку, а не динамическую.В этом случае будет вызвана функция того класса, который был указан в момент компиляции.
//            Base obj;
//        obj.display(); // Вызов функции через объект, статическая привязка
//        2.	Когда функция не объявлена как виртуальная :
//        •	Если функция не объявлена как виртуальная, компилятор также использует статическую привязку.
//            class Base {
//            public:
//                void nonVirtualFunction() {}
//        };
//
//        Base* ptr = new Base();
//        ptr->nonVirtualFunction(); // Вызов не виртуальной функции через указатель
//        Виртуальные деструкторы :
//        •	Виртуальные деструкторы используются для обеспечения корректного удаления объектов через указатель на базовый класс.
//            •	Когда объект удаляется через указатель на базовый класс, вызывается деструктор того класса, на который указывает указатель.
//            •	Если деструктор базового класса не объявлен виртуальным, деструкторы производных классов могут не вызываться, что может привести к утечкам памяти и другим проблемам.
//            class Base {
//            public:
//                virtual ~Base() {} // Виртуальный деструктор
//        };
//
//        class Derived : public Base {
//        public:
//            ~Derived() {} // Невиртуальный деструктор (хотя и необязательно)
//        };
//
//        Base* ptr = new Derived();
//        delete ptr; // Безопасное удаление через указатель на базовый класс
//        Использование виртуальных функций и виртуальных деструкторов позволяет правильно управлять памятью и обеспечивает корректное поведение при работе с полиморфными объектами через указатели на базовые классы.
//            Вопрос 41. Ввод - вывод файлов.Потоки ввода - вывода.Библиотека ввода - вывода(iostream).Группы классов библиотеки ввода - вывода.
//            Ввод - вывод файлов в C++ обеспечивается с помощью библиотеки ввода - вывода(iostream).Она предоставляет классы и объекты для работы с вводом(istream) и выводом(ostream), а также с файлами(ifstream, ofstream, fstream), консолью и другими устройствами.
//            Группы классов библиотеки ввода - вывода:
//        1.	Базовые классы потоков(ios, istream, ostream) :
//            •	ios является базовым классом для управления форматированием ввода - вывода.
//            •	istream представляет поток ввода, а ostream - поток вывода.
//            2.	Классы для работы с файлами(ifstream, ofstream, fstream) :
//            •	ifstream предназначен для ввода из файла.
//            •	ofstream предназначен для вывода в файл.
//            •	fstream обеспечивает возможность одновременного ввода и вывода из файла.
//            Пример чтения из файла и записи в файл с использованием классов ifstream и ofstream :
//#include <iostream>
//#include <fstream>
//
//        int main() {
//            std::ofstream outputFile("output.txt"); // Создание объекта для записи в файл
//
//            if (outputFile.is_open()) {
//                outputFile << "Hello, File!"; // Запись в файл
//                outputFile.close(); // Закрытие файла
//            }
//            else {
//                std::cout << "Unable to open file for writing!" << std::endl;
//            }
//
//            std::ifstream inputFile("input.txt"); // Создание объекта для чтения из файла
//            std::string line;
//
//            if (inputFile.is_open()) {
//                while (std::getline(inputFile, line)) { // Чтение из файла построчно
//                    std::cout << line << std::endl; // Вывод на экран
//                }
//                inputFile.close(); // Закрытие файла
//            }
//            else {
//                std::cout << "Unable to open file for reading!" << std::endl;
//            }
//
//            return 0;
//        }
//        Этот код открывает файл для записи и записывает в него строку "Hello, File!", затем открывает другой файл для чтения и выводит его содержимое на экран.
//            Библиотека ввода - вывода(iostream) облегчает работу с вводом, выводом и файлами в C++, предоставляя удобные классы и методы для управления данными.
//            Вопрос 42. Шаблоны функций С++
//            Шаблоны функций в C++ позволяют создавать универсальные функции, которые могут работать с разными типами данных, обеспечивая повторное использование кода.Они позволяют написать обобщенный алгоритм, который может быть использован для различных типов данных, не создавая дублированного кода для каждого типа.
//            Синтаксис шаблонов функций :
//        template <typename T>
//        T max(T a, T b) {
//            return (a > b) ? a : b;
//        }
//        •	template <typename T> -ключевое слово template, за которым следует объявление шаблона с ключевым словом typename или class, а T — это параметр шаблона, представляющий тип данных.
//            •	T max(T a, T b) — это шаблонная функция, которая принимает два аргумента типа T и возвращает максимальное значение из них.
//            Пример использования :
//        int main() {
//            int intMax = max(5, 10); // Вызов функции для типа int
//            double doubleMax = max(5.5, 10.7); // Вызов функции для типа double
//
//            return 0;
//        }
//        Шаблоны функций позволяют создавать обобщенные функции, которые могут работать с различными типами данных.При компиляции шаблоны генерируют специализированные версии для каждого использованного типа, что позволяет достичь гибкости и эффективности при написании универсального кода.
//            Вопрос 43. Шаблоны классов С++.Определение шаблона класса.Явная реализация некоторых методов для специфических типов.Полное переопределение шаблона класса для работы с некоторым особым типом.Шаблоны и дружественные функции.Шаблоны и наследование.Шаблоны и конфигурация компилятора.Достоинства и недостатки шаблонов.
//            Шаблоны классов в C++ позволяют создавать обобщенные классы, которые могут работать с различными типами данных.Они предоставляют гибкость и повторное использование кода, а также позволяют создавать классы, параметризованные типами данных.
//            Определение шаблона класса :
//        template <typename T>
//        class MyTemplate {
//        public:
//            T data;
//
//            void setData(T value) {
//                data = value;
//            }
//        };
//        •	template <typename T> -объявление шаблона класса, где T — это параметр шаблона, представляющий тип данных.
//            •	MyTemplate<T> — это шаблонный класс, который может работать с любым типом T.
//            Явная реализация некоторых методов для специфических типов :
//        template <>
//        class MyTemplate<char> {
//        public:
//            char data;
//
//            void setData(char value) {
//                data = std::toupper(value);
//            }
//        };
//        •	Этот шаблонный класс полностью переопределяет шаблон для типа char и изменяет поведение метода setData.
//            Шаблоны и дружественные функции :
//        Шаблоны классов могут также иметь дружественные функции :
//        template <typename T>
//        class MyTemplate {
//            // ...
//
//            template <typename U>
//            friend void myFriendFunction(MyTemplate<U>& obj) {
//                std::cout << "Friend function accessing data: " << obj.data << std::endl;
//            }
//        };
//        Шаблоны и наследование :
//        Шаблоны классов могут использоваться в наследовании :
//        template <typename T>
//        class Base {
//            // ...
//        };
//
//        template <typename T>
//        class Derived : public Base<T> {
//            // ...
//        };
//        Шаблоны и конфигурация компилятора :
//        Компиляторы C++ могут требовать наличие исходного кода шаблона при каждом вызове, что может увеличить размер скомпилированных файлов.Однако существуют различные методы для управления компиляцией шаблонов, такие как явная инстанциация шаблонов и использование ключевого слова export (но его поддержка не всегда полностью реализована).
//            Достоинства и недостатки шаблонов :
//    Достоинства:
//        •	Обобщение и повторное использование кода.
//            •	Гибкость при работе с разными типами данных.
//            •	Возможность оптимизации компилятором.
//            Недостатки :
//            •	Увеличение времени компиляции и размера скомпилированных файлов из - за инстанцирования шаблонов.
//            •	Могут быть сложными для понимания и отладки в некоторых случаях.
//            •	Возможность раздувания бинарных файлов из - за генерации различных версий шаблонов для разных типов данных.
